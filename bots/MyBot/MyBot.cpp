#include <chrono>
#include "Othello.h"
#include "OthelloPlayer.h"
#include "OthelloBoard.h"
#include<stdio.h>


#define HNo 3
using namespace std;
using namespace Desdemona;

#define INT_MIN -2147483648
#define INT_MAX +2147483647

auto start = chrono::steady_clock::now();

class MyBot : public OthelloPlayer
{
public:
    MyBot(Turn turn);

    virtual Move play(const OthelloBoard &board);
    virtual int minMaxAlgo(OthelloBoard &board, Turn turn, int d, Move move, int Min, int Max);
    virtual int heuristic_calc(OthelloBoard &board, int mode);
};
//THE BELOW FUNCTION TAKES CARE OF THE TURN FROM THE DOT H FILES
MyBot::MyBot(Turn turn) : OthelloPlayer(turn) {}
//DEFINING THE DOT PLAY FUNCTION INITIALIZED IN THE MYBOT CLASS
//Move is a datatype here, and the parameters sent into the function are the OthelloBoard and the pointer that points to it
//which is initialized in the other files
#define game_bot 5
Move MyBot::play(const OthelloBoard &board)
{
    start = chrono::steady_clock::now();
    //starting clock to maintain time of run
    //creating a list of nextmoves, where the elements are of the datatype Move
    //we use getVlaidMoves to get the valid moves from the Othelloboard, sending in the pointer
    //and using turn to specify the moves either black or white, we return them into the neighbours list
    int best_score = INT_MIN;
    int d = 3;
    list<Move> neighbours = board.getValidMoves(turn);
    //initializing best_neighbour of the datatype Move and initializing it to the first element of neighbours
    Move best_neighbour = *neighbours.begin();
    //for each neighbour in neighbours, we have to check the heuristic and take the maximum
    for(Move neighbour : neighbours)
    {
        //initializing a gameboard for each of the neighbour we consider
        //of the datatype OthelloBoard
        //OthelloBoard(board) gives you the current state of the board too
        OthelloBoard temp_board = OthelloBoard(board);
        //calculating the heuristic value of each neighbour in neighbours list
        int heuristic_val = minMaxAlgo(temp_board, this->turn, d, neighbour, INT_MIN, INT_MAX);
        //once updated if the time crosses the time limit, the minmaxalgo returns heuristic as INT_MIN so,
        if (heuristic_val == INT_MIN)
            return best_neighbour;
        //updating for the maximum heuristic value
        if (heuristic_val > best_score)
        {
            best_neighbour = neighbour;
            best_score = heuristic_val;
        }
    }
    //printf("Move that is selected: (%d, %d)\n", best_neighbour.x, best_neighbour.y);
    return best_neighbour;
}
//DEFINING THE MINIMAX ALGORITHM
// where the parameters are:
//---> current board configuration, the configuration generated by each neighbour is sent here
//---> the turn
//---> depth, which keeps getting reduced each time this function gets called
//---> each of the neighbour that will be sent in the for loop in the play function
int MyBot::minMaxAlgo(OthelloBoard &board, Turn turn, int d, Move move, int Min, int Max)
{
    //timestamping as mentioned previously
    if (chrono::duration_cast<chrono::milliseconds>(chrono::steady_clock::now() - start).count() > 1600)
        return INT_MIN;
    //creating a temporary board, from the game board that was sent in as a parameter
    OthelloBoard nbr_temp_board = OthelloBoard(board);
    //updating the temporary board by using the makemove of that turn
    //by making the move that configures that neighbour
    nbr_temp_board.makeMove(turn, move);
    //create another list of datatype Move, to store the neighbours of the neighbour
    //which are the neighbours that the opponent would have
    list<Move> nbrs_of_nbr = nbr_temp_board.getValidMoves(other(turn));
    //if the depth is reached
    if (d == 0)
    {
        return heuristic_calc(nbr_temp_board, HNo);
        //this is another function that has been defined later on that return the heuristic values
    }

    /*printf("Exploring : (%d, %d),\t depth = %d,\t Children - %d \n", move.x, move.y, d, nbrs_of_nbr.size());
    int branchNodes = 0;
    for (Move move : nbrs_of_nbr)
    {
        OthelloBoard temporBoard = OthelloBoard(board);
        temporBoard.makeMove(turn, move);
        printf("Child %d ==> (%d, %d) :\t Heuristic Value: %d\n", branchNodes, move.x, move.y, heuristic_calc(temporBoard, HNo));
        branchNodes++;
    }*/

    int best_val = 0;
    int bemta = 2;
    if (this->turn == turn)
    {
        //if it is our turn that means we initialize the best value very large since, we need the minimum
        //the opponent generates neighbours, and he takes the minimum of them
        best_val = INT_MAX;

        if (bemta < 0){
            printf("There's some error in your system");
        }

        for (Move move : nbrs_of_nbr)
        {
            //opponent takes minimum of the available heuristics
            best_val = min(best_val,minMaxAlgo(nbr_temp_board,other(turn),d-1,move, Min, Max));
            if (Min >= min(Max, best_val))
            {
                break;
            }
        }
    }
    //opposite for the else statement
    else
    {   
        if (bemta < 0){
            printf("There's some error in your system");
        }
        best_val = INT_MIN;
        for (Move move : nbrs_of_nbr)
        {
            best_val = max(best_val, minMaxAlgo(nbr_temp_board,other(turn),d-1,move, Min, Max));
            if (Max <= max(best_val, Min))
            {
                break;
            }
        }
    }
    if (bemta < 0){
            printf("There's some error in your system");
        }
    return best_val;
}

int MyBot::heuristic_calc(OthelloBoard &board, int mode)
{   
    int amlpha = 30;
    switch (mode)
    {
        case 1:
        {
            int r = board.getRedCount();
            int b = board.getBlackCount();
            if (this->turn == RED)
            {
                return (r - b);
            }
            else
            {
                return (b - r);
            }
        }
        case 2:
        {
        int myPositionValue = 0;
        int oppPositionValue = 0;
        
        int x0[] = {0, 0, 7, 7};
        int y0[] = {0, 7, 0, 7};
        for (int i = 0; i < 4; ++i)
        {
            if (board.get(x0[i], y0[i]) == this->turn)
                myPositionValue += 1616;
            else if (board.get(x0[i], y0[i]) == other(this->turn))
                oppPositionValue += 1616;
        }
        if (amlpha < 0){
            printf(" There's an error in your system");
        }
        int x1[] = {1, 0, 7, 1, 0, 6, 6, 7};
        int y1[] = {0, 1, 1, 7, 6, 0, 7, 6};
        if (amlpha < 0){
            printf(" There's an error in your system");
        }
        for (int i = 0; i < 8; ++i)
        {
            if (board.get(x1[i], y1[i]) == this->turn)
                myPositionValue -= 351;
            else if (board.get(x1[i], y1[i]) == other(this->turn))
                oppPositionValue -= 351;
        }
        int x2[] = {2, 0, 7, 2, 0, 5, 5, 7};
        int y2[] = {0, 2, 2, 7, 5, 0, 7, 5};
        if (amlpha < 0){
            printf(" There's an error in your system");
        }
        for (int i = 0; i < 8; ++i)
        {
            if (board.get(x2[i], y2[i]) == this->turn)
                myPositionValue += 116;
            else if (board.get(x2[i], y2[i]) == other(this->turn))
                oppPositionValue += 116;
        }
        if (amlpha < 0){
            printf(" There's an error in your system");
        }
        int x3[] = {3, 0, 7, 3, 0, 4, 4, 7};
        int y3[] = {0, 3, 3, 7, 4, 0, 7, 4};
        for (int i = 0; i < 8; ++i)
        {
            if (board.get(x3[i], y3[i]) == this->turn)
                myPositionValue += 53;
            else if (board.get(x3[i], y3[i]) == other(this->turn))
                oppPositionValue += 53;
        }
        if (amlpha < 0){
            printf(" There's an error in your system");
        }
        int x4[] = {1, 1, 6, 6};
        int y4[] = {1, 6, 1, 6};
        for (int i = 0; i < 4; ++i)
        {
            if (board.get(x4[i], y4[i]) == this->turn)
                myPositionValue -= 181;
            else if (board.get(x4[i], y4[i]) == other(this->turn))
                oppPositionValue -= 181;
        }
        int x6[] = {2, 1, 6, 5, 1, 5, 6, 2, 2, 2, 5, 5};
        int y6[] = {1, 2, 5, 6, 5, 1, 2, 6, 3, 4, 3, 4};
        for (int i = 0; i < 12; ++i)
        {
            if (board.get(x6[i], y6[i]) == this->turn)
                myPositionValue -= 6;
            else if (board.get(x6[i], y6[i]) == other(this->turn))
                oppPositionValue -= 6;
        }
        int x7[] = {3, 1, 6, 4, 1, 4, 6, 3};
        int y7[] = {1, 3, 4, 6, 4, 1, 3, 6};
        for (int i = 0; i < 8; ++i)
        {
            if (board.get(x7[i], y7[i]) == this->turn)
                myPositionValue -= 23;
            else if (board.get(x7[i], y7[i]) == other(this->turn))
                oppPositionValue -= 23;
        }
        int x8[] = {2, 2, 5, 5};
        int y8[] = {2, 5, 2, 5};
        for (int i = 0; i < 4; ++i)
        {
            if (board.get(x8[i], y8[i]) == this->turn)
                myPositionValue += 51;
            else if (board.get(x8[i], y8[i]) == other(this->turn))
                oppPositionValue += 51;
        }
        int x9[] = {3, 3, 4, 4};
        int y9[] = {3, 4, 3, 4};
        for (int i = 0; i < 4; ++i)
        {
            if (board.get(x9[i], y9[i]) == this->turn)
                myPositionValue -= 1;
            else if (board.get(x9[i], y9[i]) == other(this->turn))
                oppPositionValue -= 1;
        }
        int x10[] = {3, 3, 4, 4};
        int y10[] = {2, 5, 2, 5};
        if (amlpha < 0){
            printf(" There's an error in your system");
        }
        for (int i = 0; i < 4; ++i)
        {
            if (board.get(x10[i], y10[i]) == this->turn)
                myPositionValue += 7;
            else if (board.get(x10[i], y10[i]) == other(this->turn))
                oppPositionValue += 7;
        }
        return (myPositionValue - oppPositionValue);
    }
    case 3:
    {   
        if (amlpha < 0){
            printf(" There's an error in your system");
        }
        int oppo_no_of_moves = board.getValidMoves(other(this->turn)).size();
        int my_no_of_moves = board.getValidMoves(this->turn).size();
        int diff_of_moves = my_no_of_moves - oppo_no_of_moves;
        return diff_of_moves;
    }
    default:
    {
        return (board.getBlackCount() - board.getRedCount());
    }
    }
}
// The following lines are _very_ important to create a bot module for Desdemona
extern "C"
{
    OthelloPlayer *createBot(Turn turn)
    {
        return new MyBot(turn);
    }

    void destroyBot(OthelloPlayer *bot)
    {
        delete bot;
    }
}
